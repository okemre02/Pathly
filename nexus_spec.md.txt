NEXUS Projesi: Etkileşimli Yazılımcı Yol Haritası Mobil Uygulama Yazılım Gereksinimleri Tanım Belgesi (YGTB/SRS)I. GİRİŞ VE PROJE KAPSAMI1.1. Proje Amacı, Hedefleri ve VizyonuBu belge, özellikle yazılımcılara odaklanan, geleneksel statik yol haritası uygulamalarının ötesine geçerek kapsamlı ve etkileşimli bir öğrenim deneyimi sunan mobil uygulama "NEXUS" için teknik spesifikasyonları tanımlamaktadır. Projenin temel amacı, kullanıcıların bir yazılım dilini veya teknolojisini hangi yolu izleyerek öğrenmeleri gerektiğini göstermekle kalmayıp, aynı zamanda bu öğrenim sürecine aktif olarak yardımcı olacak gömülü öğreticiler ve anlık kod çalıştırma ortamları sağlamaktır.Projenin temel hedefleri, modern, minimalist ve gözü yormayan bir kullanıcı deneyimini (UX) ölçeklenebilir bir mimari ile birleştirmektir. Başarı kriterleri, etkileşimli öğrenim modüllerinin yüksek tamamlama oranları (F-REQ-4.2.5) ve uygulamanın sadelik ve kullanım kolaylığına dair kullanıcı memnuniyetidir (NFR-U-5.4.1).1.2. Kapsam ve KısıtlamalarGeliştirme süreci, tüm platformlarda tutarlı ve hızlı bir deneyim sunmak üzere Google tarafından geliştirilen açık kaynak kodlu bir arayüz araç takımı olan Flutter SDK kullanılarak yürütülecektir.1 Bu teknolojik seçim, iOS ve Android platformlarında çapraz platform desteği sağlarken 3, aynı zamanda hızlı geliştirme ve şık arayüzler sunma avantajlarını da beraberinde getirir.Kapsam Dahilindeki Ana Bileşenler:Flutter Mobil Uygulama: Hem iOS hem de Android için yerel olarak derlenmiş uygulama arayüzü.3Headless CMS Entegrasyonu: Tüm yol haritası ve öğretici içeriğin esnek bir API aracılığıyla yönetimi.Güvenli Uzak Kod Çalıştırma Hizmeti (Code Sandbox): Kullanıcının yazdığı kodu güvenli bir şekilde doğrulayan kritik arka uç hizmeti.İlerleme Takibi (UPPM): Kullanıcı streak, tamamlama ve başarımların yönetimi.Zorunlu Kısıtlamalar:Mimarinin ve tasarımın en önemli zorunluluğu, modern, minimalist ve sade bir yaklaşım benimsemektir. Bu, "Daha Az Daha Çoktur" felsefesine sıkı sıkıya bağlı kalmayı gerektirir.4 Uygulama, kullanıcının hedeflerini desteklemeyen gereksiz öğeleri ve içeriği eleyerek, kullanıcı deneyimini optimize etmelidir.5Ayrıca, uygulamanın kullanıcıya olanak sağlayan akışını bozmamak adına, hiçbir yerden fırlayan (unsolicited) pop-up'lar veya gereksiz bilgiler kesinlikle yasaklanmıştır. Bu gereksinim, hata, başarı ve bildirim sistemlerinin yeniden tasarlanmasını (NFR-U-5.4.1) zorunlu kılmaktadır.II. SİSTEM MİMARİSİ2.1. Katmanlı Mimari YapısıNEXUS, ölçeklenebilirliği, güvenliği ve hızlı içerik güncellemelerini sağlamak amacıyla üç ana katmandan oluşan ayrıştırılmış (decoupled) bir mimari üzerine inşa edilecektir:İstemci Katmanı (Client Layer): Flutter mobil uygulaması (UI ve iş mantığı).İçerik/API Katmanı: Headless CMS ve Firebase/Cloud veritabanı (İçerik dağıtımı ve kullanıcı verilerinin senkronizasyonu).6Yürütme Katmanı (Execution Layer): Güvenlik odaklı, izole Uzak Kod Sandbox API hizmeti (Kullanıcı kodu çalıştırma).7Bu ayrıştırma, herhangi bir katmandaki karmaşıklığın diğer katmanların performansını olumsuz etkilemesini önlemek için esastır.2.2. Ön Uç Mimarisi (Flutter)Teknolojik Seçim ve PerformansFlutter, EdTech uygulamaları geliştirmek için ideal bir araçtır.2 Skia Grafik Kitaplığını kullanması 1, uygulamanın hızlı yüklenmiş ve sorunsuz bir deneyim yaşamasını sağlar. Minimalist tasarımın temel bir performans gereksinimi vardır: arayüzdeki sadelik, akıcı animasyonlar ve anlık geri bildirimlerle desteklenmelidir. Eğer temel görüntü motoru yavaş olsaydı, "temiz" ve "gözü yormayan" UX hedefine ulaşılamazdı; bu nedenle Flutter'ın yerel performansa yakın temelinin seçimi, istenen Fonksiyonel Olmayan Gereksinimlerin (NFR) sağlanmasında kritik bir rol oynar.Kod Yapısı ve Durum YönetimiUygulamanın test edilebilirliğini ve ölçeklenebilirliğini sürdürmek için, mimari, BLoC (Business Logic Component) veya Riverpod gibi gelişmiş durum yönetimi yaklaşımlarını kullanmalıdır.8 Kod yapısı, RoadmapFeature ve karmaşık LearningModuleFeature gibi ana özelliklere göre organize edilmelidir.10Özellikle yüksek riskli veya potansiyel olarak yavaş olan bileşenlerin (örneğin, WebView aracılığıyla gömülen kod düzenleyici istemci mantığı 11) ana uygulama akışından izole edilmesi gerekmektedir. Bu mimari izolasyon, eğer editör veya Code Sandbox iletişimi gecikme yaşarsa, bu sorunun ana uygulamanın navigasyon ve tepkiselliğini (NFR-P-5.1.3) etkilemesini engeller.2.3. Arka Uç ve Hizmet Mimarisiİçerik Yönetimi (Headless CMS)Gereksinimler, dinamik, etkileşimli öğrenme içeriği sağlama zorunluluğu nedeniyle bir Headless CMS kullanımını zorunlu kılmaktadır.13Esneklik ve Özelleştirme: Headless CMS, içerik yönetimini sunum katmanından (Flutter uygulaması) tamamen ayırır.14 Bu ayrıştırma, içerik ekiplerinin yazılım dilleri için yol haritaları ve öğreticiler dahil olmak üzere yapılandırılmış içerikleri kolayca yaratmasına ve yayınlamasına olanak tanır.15Hızlı Dağıtım: Geleneksel CMS'lerin aksine, Headless CMS bir API aracılığıyla içerik sunar.14 Bu, bir kod parçacığındaki hatanın düzeltilmesi veya yeni bir yol haritasının eklenmesi gibi kritik içerik güncellemelerinin, uygulama mağazası onayı beklemeden anında uygulamaya yansımasını sağlar.Stratejik İçerik Modelleme: Standart metin alanlarının ötesinde, CMS'in Code Sandbox için gerekli olan yapılandırılmış yürütme verilerini (TestCases, InitialCodeSnippet) JSON yükleri olarak modellemesi gerekmektedir. Bu, CMS'i etkileşimli öğrenim modülünün (F-REQ-4.2.3) yapılandırma merkezi haline getirir.Etkileşimli Yürütme Hizmeti (Code Sandbox API)Bu, uygulamanın temel farklılaştırıcı özelliğini oluşturan en kritik ve güvenlik açısından en hassas arka uç bileşenidir.Güvenlik Odaklı Sandboxing: Kullanıcılar tarafından gönderilen kod, sunucuya zarar verme veya kaynakları tüketme potansiyeline sahip olduğu için, Sandbox hizmeti, kodu izole, geçici ve kesinlikle kaynak sınırlı bir ortamda çalıştırmalıdır (NFR-S-5.3.1).7İş Akışı: Hizmet, kullanıcı kodunu, dil meta verilerini ve eşleşen test senaryolarını alır, yürütür ve yalnızca doğrulama sonuçlarını (başarı/hata) istemciye geri gönderir.Veri Depolama (Firebase/Cloud DB): Kullanıcıların ilerlemesini, streaklerini ve gamifikasyon verilerini gerçek zamanlı olarak depolamak ve senkronize etmek için Firebase gibi ölçeklenebilir, gerçek zamanlı veritabanları kullanılacaktır.6III. VERİ MODELLERİ VE İÇERİK YAPILANDIRMASISistem, içeriği ve kullanıcı ilerlemesini yönetmek için üç ana yapısal modele dayanır.3.1. Yol Haritası Görselleştirme İçin İçerik Yapısı (DAG Modeli)Yol haritası, beceri ağaçlarını ve bağımlılık diyagramlarını temsil eden Yönlendirilmiş Döngüsel Olmayan Grafik (DAG) yapısında modellenmelidir.18 Bu yapı, bir öğrenme yolu üzerindeki adımların mantıksal sırasını sağlar. Bu yapının görselleştirilmesi için fl_nodes veya graph_builder gibi Flutter paketlerinin kullanımı önerilir.18Roadmap Node Veri ModeliAlan AdıVeri TipiAçıklamaGereksinimNodeIDUUIDÖğrenme düğümünün benzersiz kimliği.ZorunluTitleStringBeceri adı (örneğin, "Asenkron Dart Programlama").ZorunluPrerequisitesArray (NodeID)Bu düğümün kilidini açmak için gerekli olan üst düğümlerin listesi.F-REQ-4.3.3 için kritikTutorialRefIDUUIDİlgili öğrenme modülüne bağlantı.ZorunluLanguageTypeEnumSözdizimi vurgulama ve Sandbox yürütmesi için kodlama dilini tanımlar.F-REQ-4.2.2 için kritikBu yapı, yalnızca bir görsel temsil değil; öğrenme ilerlemesinin (UPPM) çekirdek mantıksal motorudur. Sistem, bir düğümün kilidinin açılıp açılmayacağını, yalnızca tüm Prerequisites alanındaki ebeveyn düğümlerin tamamlanma durumuna bakarak hesaplar.3.2. Öğrenme Modülü Veri Modeli (Etkileşimli Yük)Bu şema, etkileşimli dersin içeriğini ve kod doğrulama için gerekli olan gizli verileri tanımlar.Learning Module Veri ModeliAlan AdıVeri TipiAçıklamaGereksinimModuleIDUUIDModülün benzersiz kimliği.ZorunluInstructionTextZengin MetinÖğretim paragrafları, örnekler ve talimatlar.ZorunluInitialCodeSnippetKod BloğuKullanıcının Monaco Editor'de başlayacağı varsayılan kod şablonu.12ZorunluTestCasesJSON DizisiSandbox API'ye gönderilen girdi, beklenen çıktı ve doğrulama mantığını içeren yapılandırılmış gizli veri.Doğrulama için zorunluExternalResourcesArray (URL, Başlık)Resmi belgelere veya video eğitimlerine bağlantılar.Opsiyonel3.3. Kullanıcı İlerlemesi Kalıcılık Modeli (UPPM)Kullanıcı ilerlemesinin kalıcı ve platformlar arası tutarlı olması gerekmektedir. Bu veriler Firebase gibi ölçeklenebilir bir arka uçta depolanmalı ve yerel cihazda önbelleğe alınmalıdır.6Completion Tracking: Kullanıcının tamamladığı tüm NodeID'leri ve CompletionTimestamp değerlerini saklar.Gamification Metrics: Kullanıcı katılımını artırmak için teqani_rewards veya track gibi paketlerle entegre edilebilecek metrikleri içerir.21 Bu, ActiveStreak (Günlük öğrenme serisi) ve BestStreak (En iyi rekor) gibi verileri içerir.Performance Metrics: Öğrenme etkinliğine ayrılan sürenin takibi, geliştirme ve analiz için önemlidir (TimeSpent_NodeID).IV. FONKSİYONEL GEREKSİNİMLER (F-REQS)Fonksiyonel gereksinimler, uygulamanın temel davranışlarını ve özelliklerini tanımlar.234.1. Yol Haritası Görselleştirme (DAG Rendering)F-REQ-4.1.1 (Grafik Yükleme ve Oluşturma)Uygulama, Başsız CMS'den yol haritası verilerini hızlı bir şekilde almalı, Prerequisites alanına göre DAG yapısını oluşturmalı ve bu yapıyı, mobil ekranda verimli bir şekilde hareket ettirilebilen (pan/zoom) bir görselleştirmeye dönüştürmelidir.18F-REQ-4.1.2 (Düğüm Etkileşimliliği)Yol haritası üzerindeki her bir düğüm etkileşimli bir buton görevi görmelidir. Bir düğmeye dokunulduğunda, düğümün mevcut durumuna göre bir eylem tetiklenmelidir:Durum 'Mevcut' veya 'Devam Ediyor' ise: İlgili TutorialRefID kullanılarak LearningModule görünümüne geçiş yapılmalıdır.Durum 'Kilitli' ise: Kullanıcının engelleyici ön koşulları tamamlaması gerektiğine dair net, ancak dikkat dağıtıcı olmayan (non-obtrusive) bir geri bildirim sağlanmalıdır.F-REQ-4.1.3 (Yol Vurgulama)Kullanıcının mevcut ilerlemesi ve seçtiği kariyer yoluna göre, tamamlanan, mevcut ve kilitli düğümleri net bir şekilde ayırmak için görsel vurgulama teknikleri kullanılmalıdır (örneğin, renk paletinde sınırlı ancak etkili renk kullanımı).4.2. Etkileşimli Öğrenme ve Kod YürütmeBu bölüm, NEXUS'u statik yol haritalarından ayıran temel işlevselliği detaylandırır.F-REQ-4.2.1 (Gömülü Editör Ortamı)LearningModule ekranı, geliştiricilerin alışık olduğu yüksek kaliteli bir düzenleme deneyimi sağlamak amacıyla, bir WebView içine Monaco Editor gibi profesyonel bir kod düzenleyiciyi entegre etmelidir.12 WebView kullanımı, bu karmaşık arayüzün çapraz platformda tutarlı bir şekilde sunulması için gerekli bir teknolojik uzlaşmadır. Gömülü düzenleyici, kullanıcı odağını en üst düzeye çıkarmak için ekranın en büyük bölümünü kaplamalıdır (Bkz. VI.6.4).F-REQ-4.2.2 (Kod Senkronizasyonu ve Hazırlık)Modül yüklendiğinde, InitialCodeSnippet verisi CMS'den alınmalı ve gömülü editöre yüklenmelidir. Kullanıcı kodu düzenledikten sonra, Gönder butonuna basıldığında, editördeki son kullanıcı kodu, Sandbox API'ye gönderilmek üzere yerel Flutter istemcisine güvenilir bir şekilde iletilmelidir.F-REQ-4.2.3 (Doğrulama Akışı)Kod gönderme eylemi üzerine, Flutter istemcisi kullanıcı kodunu, ilgili LanguageType'ı ve modüle ait gizli TestCases yükünü Code Sandbox API'sine eşzamansız bir şekilde iletir.17 Bu işlem, güvenlik ve performans gereksinimlerine uymak için arka uçta izole bir yürütme ortamında gerçekleşir.F-REQ-4.2.4 (Sonuç Ekranı)Code Sandbox API'sinden gelen yürütme sonuçları (geçti/kaldı, konsol çıktısı, hata izlemesi) anlık olarak, LearningModule görünümündeki özel bir konsol bölmesinde gösterilmelidir. Bu geri bildirim, kullanıcının kodlama akışını kesintiye uğratmamak için kesinlikle modal olmayan bir yapıda olmalıdır (NFR-U-5.4.1).4.3. İlerleme ve Durum YönetimiF-REQ-4.3.1 (Tamamlama Mantığı)Bir öğrenme düğümü, ancak ve ancak Code Sandbox API'sinden alınan 'Doğrulama Başarısı' sinyali (F-REQ-4.2.4) ile başarılı bir şekilde tamamlanmış sayılmalıdır.F-REQ-4.3.2 (Bağımlılık Çözünürlüğü)Bir düğümün Tamamlandı statüsü, DAG yapısındaki tüm bağımlı alt düğümlerde (children) eşzamansız bir durum kontrolünü tetiklemelidir.18 Bu kontrol, ilgili alt düğümlerin durumunu anında 'Kilitli'den 'Mevcut'a geçirmeli ve kullanıcının ilerlemesini görsel olarak yansıtmalıdır.V. FONKSİYONEL OLMAYAN GEREKSİNİMLER (NFRs)Fonksiyonel olmayan gereksinimler, sistemin kalitesini, ölçeklenebilirliğini, güvenliğini ve minimalist tasarımın gerektirdiği kullanıcı deneyimini tanımlar.255.1. Performans Gereksinimleri (NFR-P)NFR-P-5.1.1 (Roadmap Yükleme Süresi)Uygulamanın başlangıç yüklemesi ve ana yol haritası grafiğinin çizilmesi $T < 1.0$ saniye içinde tamamlanmalıdır. Bu, özellikle Flutter'ın Skia tabanlı hızlı grafikleri ve ölçeklenebilir arka uç (Firebase/Headless CMS) kullanımıyla sağlanmalıdır.1NFR-P-5.1.2 (Kod Yürütme Gecikmesi)Kod Sandbox'ı zorlukları için uçtan uca yanıt süresi (kullanıcının göndermesinden sonucun geri gelmesine kadar geçen süre) $T < 3.0$ saniye altında olmalıdır.23 Bu kısıtlama kritiktir. Kullanıcı kodunun güvenli bir şekilde izole edilmiş ortamlarda (sandboxing) çalıştırılması 7, kaçınılmaz olarak bir gecikme yaratır. Bu nedenle, mimari karar, mutlak güvenlik ile yüksek performans ihtiyacı arasında bir denge kurmakta ve güvenlik lehine bir miktar gecikmeyi kabul etmektedir. 3.0 saniyenin üzerindeki herhangi bir gecikme, kullanıcıya görsel olarak bildirilmeli ancak ana akışı engellememelidir.NFR-P-5.1.3 (Kullanıcı Arayüzü Tepkiselliği)Uygulama, karmaşık DAG manipülasyonları (kaydırma, yakınlaştırma) ve ekran geçişleri sırasında bile tutarlı bir 60 FPS (Kare/Saniye) hızını korumalıdır. Bu, minimalist tasarımın beklediği akıcılık ve cilalı his için zorunludur.55.2. Ölçeklenebilirlik Gereksinimleri (NFR-S)NFR-S-5.2.1 (Eş Zamanlı Kullanıcılar)Sistem, Code Sandbox hizmetinde performans düşüşü (NFR-P-5.1.2 ihlali) veya kesinti olmaksızın en az 10.000 eş zamanlı, aktif olarak kod yazan kullanıcıyı destekleyebilmelidir.25NFR-S-5.2.2 (Mimari Esneklik)Başsız CMS ve Firebase gibi ayrıştırılmış hizmetlerin kullanımı 14, içerik dağıtımını ve kullanıcı veritabanını dikey ölçeklendirme sınırlamalarından kurtararak yatay ölçeklenebilirliği garantiler.65.3. Güvenlik Gereksinimleri (NFR-S)NFR-S-5.3.1 (Sandbox İzolasyonu)Code Sandbox Yürütme Hizmeti, potansiyel kötü amaçlı kodun host sisteme erişmesini veya diğer kullanıcı verilerini etkilemesini önlemek için Sandbox2 gibi araçlar veya Linux konteynerleri kullanılarak çekirdek düzeyinde izolasyon sağlamalıdır.7 Çalıştırılan tüm kullanıcı kodu, potansiyel tehdit olarak kabul edilmelidir.NFR-S-5.3.2 (API Yetkilendirmesi)İstemci ile API Katmanı arasındaki tüm iletişim, İçerik Yönetim Sisteminden gelen API'ler de dahil olmak üzere, JWT (JSON Web Token) tabanlı yetkilendirme ile güvence altına alınmalıdır.275.4. Kullanılabilirlik ve Minimalizm Gereksinimleri (NFR-U)NFR-U-5.4.1 (Non-Obtrusive Geri Bildirim)Uygulama, dikkati dağıtan veya akışı bölen hiçbir unsura izin vermemelidir. Bu, istenmeyen tam ekran pop-up'ların veya reklam pencerelerinin yasaklanması anlamına gelir. Kritik geri bildirimler (başarı, hata, ilerleme güncellemeleri) yalnızca geçici Snackbar bildirimleri, durum çubuğu değişiklikleri veya hassas mikro-animasyonlar aracılığıyla iletilmelidir. Bu, kullanıcı odağını korumak için tasarlanmış açık bir "Geri Bildirim Hiyerarşisi" gerektirir.NFR-U-5.4.2 (Netlik ve Odak)Tasarım, geliştiricilerin uzun süreler boyunca konuya odaklanmasını sağlamak amacıyla beyaz boşluğu (whitespace) maksimize etmeli ve sınırlı, tutarlı bir renk paleti kullanmalıdır.5NFR-U-5.4.3 (Erişilebilirlik)Geliştirici kitlesi için yüksek kontrastlı, göz yormayan bir tema (zorunlu Karanlık Mod) sunulmalıdır. Basit tasarımların daha kalıcı bir estetik çekiciliğe sahip olma eğilimi, bu tasarım felsefesinin benimsenmesini desteklemektedir.5VI. MİNİMALİST KULLANICI ARAYÜZÜ/DENEYİMİ (UI/UX) SPESİFİKASYONLARI6.1. Tasarım Estetiği ve İlkeleriMinimalizm, günümüzün dijital tasarım ortamında hakim bir eğilimdir ve UX tasarımında etkinliği artırmak için kritiktir.4Flat Design (Düz Tasarım): Uygulama arayüzü, minimalizmin temelini oluşturan düz tasarım ilkelerini sıkı bir şekilde uygulamalıdır. Gereksiz gölgeler, gradyanlar veya dokular kaldırılmalıdır.4Sınırlı Palet: Birincil renk şeması monokromatik olmalı (örneğin, koyu zeminler ve açık metin) ve sadece etkileşimli öğeler, durum göstergeleri veya tamamlama işaretleri için tek bir vurgu rengi kullanılmalıdır.Tipografi: Kod sunumu ve genel arayüz metni için okunaklı, temiz ve yüksek kontrastlı standart sans-serif yazı tipleri seçilmelidir.6.2. Etkileşim ve Mikro-Geri BildirimNFR-U-5.4.1'e uymak için, kullanıcı etkileşimi, modal pencereler yerine mikro-geri bildirimlere dayanacaktır.Haptik Entegrasyon: Önemli kullanıcı eylemlerini (örneğin, bir düğümün kilidini açma, kod gönderme başarısı) onaylamak için dokunsal geri bildirimler (haptics) kullanılmalıdır.26 Bu, kullanıcıya arayüzün tepki verdiğini, dikkat dağıtmadan veya görsel karmaşa yaratmadan hissettirir.Akıcı Animasyonlar: Navigasyon geçişleri ve özellikle karmaşık grafik manipülasyonları sırasında akıcı, fizik tabanlı animasyonlar kullanılmalıdır. Bu akıcılık, minimalist arayüzün "cilalı" ve hızlı hissetmesini sağlar.26Hata Yönetimi: API veya Sandox'tan kaynaklanan kritik hatalar, geçerli görünüm durumunu koruyarak ekranın üst kısmında kalıcı olmayan bir durum başlığı (status banner) aracılığıyla bildirilmelidir.6.3. Yol Haritası Ekran Düzeni SpesifikasyonuYol haritası ekranı, kullanıcıya yolunu net bir şekilde göstermeye odaklanmalıdır.Düğüm Görünümü: Düğümler (Node'lar), sadece Başlık ve Temel Durum (Kilitli, Mevcut, Tamamlandı) göstergelerini içermelidir. Karmaşık ikonografi veya metin yığınlarından kaçınılmalıdır.4Kontrol Yoğunluğu: Yakınlaştırma, kaydırma ve filtreleme gibi kontrol öğeleri minimuma indirilmeli ve ekranın görselleştirme alanını en üst düzeye çıkarmak için kenarlara gizlenmelidir.6.4. Öğrenme Modülü Ekran Düzeni SpesifikasyonuBu ekran, kullanıcının kodlama görevine odaklanmasını sağlamak için tasarlanmıştır.Odak Alanı Tahsisi: Ekran, iki ana bölgeye ayrılmalıdır: Talimat Paneli ve Kod Düzenleyici/Konsol.Kod Düzenleyici Alanı: Kod Düzenleyici, geliştiricinin odaklanması için ekranın alanının yaklaşık %70 ila %80'ini kaplamalıdır. Bu alanın büyük olması, profesyonel bir IDE deneyimi sağlama hedefini desteklemektedir.Konsol Çıktısı: Kod yürütme sonuçları, düzenleyici penceresinin hemen altında bulunan özel, salt okunur bir konsol bölmesinde sunulmalıdır. Bu konumlandırma, sonuçların anında ve bağlam içinde görülmesini sağlarken, kullanıcı arayüzünü karıştırmaz.Gömülü Editör Uyumu: WebView içindeki Monaco Editor, etrafındaki native Flutter bileşenleriyle (örneğin, Talimat Paneli ve Konsol) görsel olarak kusursuz bir şekilde harmanlanmalıdır. Düz tasarımın uygulanması, gömülü web içeriğinin "native" olmayan hissiyatını azaltmaya yardımcı olacaktır.28VII. TEMEL TESLİMATLAR VE DOĞRULAMAProjenin başarısı, yalnızca işlevselliğin doğru çalışmasına değil, aynı zamanda belirtilen minimalist kalite standartlarının karşılanmasına bağlıdır.7.1. Kritik Doğrulama NoktalarıGereksinim KategorisiDoğrulama TestiBaşarı EşiğiF-REQ-4.2.3 (Fonksiyonellik)Kullanıcıdan alınan doğru çözümü Sandbox API'ye gönderme.Sandbox'ın 'Doğrulama Başarısı' yanıtını almalı ve UPPM'yi güncellemelidir.NFR-P-5.1.2 (Performans)100 eş zamanlı kod gönderme denemesinde yanıt süresi.Maksimum gecikme $T < 3.0$ saniye altında kalmalıdır.NFR-S-5.3.1 (Güvenlik)Sandbox ortamından kasıtlı olarak dosya sistemi erişimi veya yetkisiz ağ çağrısı denemesi.Host sunucuya veya diğer kullanıcılara sıfır etkiyle deneme engellenmeli ve sistem hatası döndürülmelidir.NFR-U-5.4.1 (Kullanılabilirlik)Yol Haritası, Öğrenme Modülü ve Profil ekranları arasında gezinme.Tam ekran pop-up reklam veya izinsiz modal tetiklenmemelidir.7.2. Sonuç ve ÖnerilerNEXUS projesinin başarısı, statik yol haritası konseptini dinamik, etkileşimli bir öğrenme deneyimine dönüştürme yeteneğine bağlıdır. Bu dönüşüm, üç kritik mimari karara dayanmaktadır:Headless CMS Zorunluluğu: Öğretici ve kod parçacığı içeriğinin hızlı bir şekilde güncellenmesi gerektiğinden, geleneksel CMS'ler yerine Başsız CMS kullanımı, içerik kalitesinin ve doğruluğunun anında korunmasını sağlar. Bu mimari, içeriğin API aracılığıyla esnek bir şekilde sunulmasını garanti eder.14Sandbox Güvenliği ve Performans Uzlaşması: Uzak kod yürütme, uygulamanın temel değer teklifidir. Ancak güvenlik (Sandbox izolasyonu) ile hız (3.0s gecikme kısıtlaması) arasında bir uzlaşma gereklidir. Geliştirme ekibi, güvenlikten ödün vermemek adına, bu gereksinimin sağlanması için optimize edilmiş, hafif sanal ortamlar kullanmaya odaklanmalıdır.17Minimalist Tasarımın Teknik Uygulaması: İstenen minimalist UX'i (NFR-U-5.4.1) sağlamak için, teknik mimari (BLoC/Riverpod) ve Flutter'ın yüksek performanslı Skia motoru 1 kritik öneme sahiptir. Yüksek performanslı bir alt yapı, kullanıcı etkileşimlerinin akıcı olmasını sağlayarak sadeliğin algılanan değerini artırır. Bu, gereksiz görsel karmaşanın yasaklanmasıyla birleştiğinde, NEXUS'un rakip platformlardan ayrışmasını sağlayacaktır.Özetle, NEXUS'un geliştirme süreci, sadece bir yazılım uygulaması geliştirmek değil, aynı zamanda geliştirici odaklı, güvenli ve distraktif olmayan bir öğrenme ortamı oluşturmak için karmaşık teknik zorlukların (Sandboxing ve DAG görselleştirme) üstesinden gelmeyi gerektirmektedir.